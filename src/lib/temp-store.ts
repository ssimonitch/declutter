// Temporary Storage Layer for Capture Flow
// Handles temporary storage of images and analysis data before permanent save
// Uses IndexedDB via Dexie to avoid sessionStorage size limitations

import Dexie, { Table } from "dexie";
import type { ImageQuality } from "./types";

// Analysis data interface from Gemini API response
interface AnalysisData {
  nameJapaneseSpecific?: string;
  nameEnglishSpecific?: string;
  nameJapaneseGeneric?: string;
  nameEnglishGeneric?: string;
  description?: string;
  category?: string;
  condition?: "new" | "like_new" | "good" | "fair" | "poor";
  onlineAuctionPriceJPY?: {
    low: number;
    high: number;
    confidence: number;
  };
  thriftShopPriceJPY?: {
    low: number;
    high: number;
    confidence: number;
  };
  recommendedAction?: "keep" | "online" | "thrift" | "donate" | "trash";
  actionRationale?: string;
  marketplaces?: string[];
  searchQueries?: string[];
  specialNotes?: string;
  keywords?: string[];
  disposalCostJPY?: number;
}

// Temporary capture data interface
export interface TempCapture {
  id?: string; // Auto-generated by Dexie
  photo: Blob; // Compressed image blob
  thumbnail: Blob; // Thumbnail blob
  quality: ImageQuality; // Quality setting used
  analysisData: AnalysisData; // AI analysis result from Gemini
  municipalityCode: string; // Selected municipality
  realmId?: string | null; // Optional realm ID for family sharing
  createdAt: string; // ISO timestamp
}

// Dexie database for temporary storage
class TempStorage extends Dexie {
  tempCaptures!: Table<TempCapture>;

  constructor() {
    super("SuzuMemoTempDB");

    this.version(1).stores({
      tempCaptures: "++id, createdAt", // Auto-increment ID, indexed by creation time
    });
  }
}

// Lazy initialization for SSR safety
let tempDbInstance: TempStorage | null = null;

/**
 * Get temp database instance with lazy initialization
 */
function getTempDb(): TempStorage {
  if (!tempDbInstance) {
    if (typeof window === "undefined") {
      throw new Error("TempStorage must be used in the browser");
    }
    tempDbInstance = new TempStorage();
  }
  return tempDbInstance;
}

/**
 * Save temporary capture data
 * @param capture - Capture data to save
 * @returns Promise<string> - Generated temp ID
 */
export async function saveTempCapture(
  capture: Omit<TempCapture, "id" | "createdAt">,
): Promise<string> {
  try {
    const tempData: Omit<TempCapture, "id"> = {
      ...capture,
      createdAt: new Date().toISOString(),
    };

    // Add to temp database and get auto-generated ID
    const id = await getTempDb().tempCaptures.add(tempData as TempCapture);

    // Trigger cleanup of old entries (fire and forget)
    cleanupOldEntries().catch((error) =>
      console.warn("Failed to cleanup old temp entries:", error),
    );

    return id.toString();
  } catch (error) {
    console.error("Error saving temp capture:", error);
    throw new Error("Failed to save temporary capture data");
  }
}

/**
 * Get temporary capture data by ID
 * @param tempId - Temporary ID
 * @returns Promise<TempCapture | undefined> - Capture data or undefined if not found
 */
export async function getTempCapture(
  tempId: string,
): Promise<TempCapture | undefined> {
  try {
    // Clean up old entries first
    await cleanupOldEntries();

    // Convert string ID to number (Dexie auto-increment IDs are numbers)
    const id = parseInt(tempId, 10);
    if (isNaN(id)) {
      console.warn("Invalid temp ID format:", tempId);
      return undefined;
    }

    return await getTempDb().tempCaptures.get(id);
  } catch (error) {
    console.error("Error getting temp capture:", error);
    throw new Error("Failed to retrieve temporary capture data");
  }
}

/**
 * Delete temporary capture data by ID
 * @param tempId - Temporary ID to delete
 * @returns Promise<void>
 */
export async function deleteTempCapture(tempId: string): Promise<void> {
  try {
    const id = parseInt(tempId, 10);
    if (isNaN(id)) {
      console.warn("Invalid temp ID format for deletion:", tempId);
      return;
    }

    await getTempDb().tempCaptures.delete(id);
  } catch (error) {
    console.error("Error deleting temp capture:", error);
    throw new Error("Failed to delete temporary capture data");
  }
}

/**
 * Clean up temporary entries older than 24 hours
 * This is called automatically on save/get operations
 * @returns Promise<number> - Number of entries cleaned up
 */
export async function cleanupOldEntries(): Promise<number> {
  try {
    const twentyFourHoursAgo = new Date(
      Date.now() - 24 * 60 * 60 * 1000,
    ).toISOString();

    // Find all entries older than 24 hours
    const oldEntries = await getTempDb()
      .tempCaptures.where("createdAt")
      .below(twentyFourHoursAgo)
      .toArray();

    if (oldEntries.length === 0) {
      return 0;
    }

    // Delete old entries
    const idsToDelete = oldEntries.map((entry) => entry.id!);
    await getTempDb().tempCaptures.bulkDelete(idsToDelete);

    console.log(`Cleaned up ${oldEntries.length} old temporary captures`);
    return oldEntries.length;
  } catch (error) {
    console.error("Error cleaning up old temp entries:", error);
    // Don't throw - cleanup is not critical
    return 0;
  }
}

/**
 * Get count of temporary entries (for debugging/monitoring)
 * @returns Promise<number> - Number of temp entries
 */
export async function getTempCaptureCount(): Promise<number> {
  try {
    return await getTempDb().tempCaptures.count();
  } catch (error) {
    console.error("Error getting temp capture count:", error);
    return 0;
  }
}

/**
 * Clear all temporary entries (for development/testing)
 * WARNING: This will delete all temporary data!
 * @returns Promise<void>
 */
export async function clearAllTempCaptures(): Promise<void> {
  try {
    await getTempDb().tempCaptures.clear();
    console.log("Cleared all temporary captures");
  } catch (error) {
    console.error("Error clearing temp captures:", error);
    throw new Error("Failed to clear temporary captures");
  }
}

/**
 * Get temporary storage statistics
 * @returns Promise<{count: number; oldestEntry?: string; newestEntry?: string}>
 */
export async function getTempStorageStats(): Promise<{
  count: number;
  oldestEntry?: string;
  newestEntry?: string;
}> {
  try {
    const count = await getTempDb().tempCaptures.count();

    if (count === 0) {
      return { count: 0 };
    }

    // Get oldest and newest entries
    const [oldest] = await getTempDb()
      .tempCaptures.orderBy("createdAt")
      .limit(1)
      .toArray();

    const [newest] = await getTempDb()
      .tempCaptures.orderBy("createdAt")
      .reverse()
      .limit(1)
      .toArray();

    return {
      count,
      oldestEntry: oldest?.createdAt,
      newestEntry: newest?.createdAt,
    };
  } catch (error) {
    console.error("Error getting temp storage stats:", error);
    return { count: 0 };
  }
}

/**
 * Initialize temp database (call once when app starts)
 */
export async function initializeTempStorage(): Promise<void> {
  if (typeof window === "undefined") {
    return;
  }

  try {
    const db = getTempDb();
    // Test that it works
    await db.tempCaptures.count();
    console.log("Temp storage initialized successfully");

    // Run initial cleanup
    const cleanedCount = await cleanupOldEntries();
    if (cleanedCount > 0) {
      console.log(`Initial cleanup: removed ${cleanedCount} old temp entries`);
    }
  } catch (error) {
    console.error("Temp storage initialization error:", error);
    throw new Error("Failed to initialize temporary storage");
  }
}

/**
 * Reset temp database (for development)
 * WARNING: This will delete all temporary data!
 */
export async function resetTempStorage(): Promise<void> {
  if (typeof window === "undefined") {
    throw new Error("Temp database operations must be done in the browser");
  }

  try {
    // Delete the existing database
    await Dexie.delete("SuzuMemoTempDB");

    // Clear the instance
    tempDbInstance = null;

    // Re-initialize
    getTempDb();

    console.log("Temp storage reset successfully");
  } catch (error) {
    console.error("Error resetting temp storage:", error);
    throw new Error("Failed to reset temporary storage");
  }
}
